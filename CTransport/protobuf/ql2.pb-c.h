/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: ql2.proto */

#ifndef PROTOBUF_C_ql2_2eproto__INCLUDED
#define PROTOBUF_C_ql2_2eproto__INCLUDED

//#include <protobuf-c/protobuf-c.h>
#include "protobuf-c.h"

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1003001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _VersionDummy VersionDummy;
typedef struct _Query Query;
typedef struct _Query__AssocPair Query__AssocPair;
typedef struct _Frame Frame;
typedef struct _Backtrace Backtrace;
typedef struct _Response Response;
typedef struct _Datum Datum;
typedef struct _Datum__AssocPair Datum__AssocPair;
typedef struct _Term Term;
typedef struct _Term__AssocPair Term__AssocPair;


/* --- enums --- */

/*
 * non-conforming protobuf libraries
 * This enum contains the magic numbers for your version.  See **THE HIGH-LEVEL
 * VIEW** for what to do with it.
 */
typedef enum _VersionDummy__Version {
  VERSION_DUMMY__VERSION__V0_1 = 1063369270,
  /*
   * Authorization key during handshake
   */
  VERSION_DUMMY__VERSION__V0_2 = 1915781601,
  /*
   * Authorization key and protocol during handshake
   */
  VERSION_DUMMY__VERSION__V0_3 = 1601562686,
  /*
   * Queries execute in parallel
   */
  VERSION_DUMMY__VERSION__V0_4 = 1074539808,
  /*
   * Users and permissions
   */
  VERSION_DUMMY__VERSION__V1_0 = 885177795
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VERSION_DUMMY__VERSION)
} VersionDummy__Version;
/*
 * The protocol to use after the handshake, specified in V0_3
 */
typedef enum _VersionDummy__Protocol {
  VERSION_DUMMY__PROTOCOL__PROTOBUF = 656407617,
  VERSION_DUMMY__PROTOCOL__JSON = 2120839367
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(VERSION_DUMMY__PROTOCOL)
} VersionDummy__Protocol;
typedef enum _Query__QueryType {
  /*
   * Start a new query.
   */
  QUERY__QUERY_TYPE__START = 1,
  /*
   * Continue a query that returned [SUCCESS_PARTIAL]
   */
  QUERY__QUERY_TYPE__CONTINUE = 2,
  /*
   * (see [Response]).
   */
  /*
   * Stop a query partway through executing.
   */
  QUERY__QUERY_TYPE__STOP = 3,
  /*
   * Wait for noreply operations to finish.
   */
  QUERY__QUERY_TYPE__NOREPLY_WAIT = 4,
  /*
   * Get server information.
   */
  QUERY__QUERY_TYPE__SERVER_INFO = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(QUERY__QUERY_TYPE)
} Query__QueryType;
typedef enum _Frame__FrameType {
  /*
   * Error occurred in a positional argument.
   */
  FRAME__FRAME_TYPE__POS = 1,
  /*
   * Error occurred in an optional argument.
   */
  FRAME__FRAME_TYPE__OPT = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(FRAME__FRAME_TYPE)
} Frame__FrameType;
typedef enum _Response__ResponseType {
  /*
   * These response types indicate success.
   */
  /*
   * Query returned a single RQL datatype.
   */
  RESPONSE__RESPONSE_TYPE__SUCCESS_ATOM = 1,
  /*
   * Query returned a sequence of RQL datatypes.
   */
  RESPONSE__RESPONSE_TYPE__SUCCESS_SEQUENCE = 2,
  /*
   * Query returned a partial sequence of RQL
   */
  RESPONSE__RESPONSE_TYPE__SUCCESS_PARTIAL = 3,
  /*
   * datatypes.  If you send a [CONTINUE] query with
   * the same token as this response, you will get
   * more of the sequence.  Keep sending [CONTINUE]
   * queries until you get back [SUCCESS_SEQUENCE].
   */
  /*
   * A [NOREPLY_WAIT] query completed.
   */
  RESPONSE__RESPONSE_TYPE__WAIT_COMPLETE = 4,
  /*
   * The data for a [SERVER_INFO] request.  This is
   */
  RESPONSE__RESPONSE_TYPE__SERVER_INFO = 5,
  /*
   * These response types indicate failure.
   */
  /*
   * Means the client is buggy.  An example is if the
   */
  RESPONSE__RESPONSE_TYPE__CLIENT_ERROR = 16,
  /*
   * client sends a malformed protobuf, or tries to
   * send [CONTINUE] for an unknown token.
   */
  /*
   * Means the query failed during parsing or type
   */
  RESPONSE__RESPONSE_TYPE__COMPILE_ERROR = 17,
  /*
   * checking.  For example, if you pass too many
   * arguments to a function.
   */
  /*
   * Means the query failed at runtime.  An example is
   */
  RESPONSE__RESPONSE_TYPE__RUNTIME_ERROR = 18
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__RESPONSE_TYPE)
} Response__ResponseType;
/*
 * If `ResponseType` is `RUNTIME_ERROR`, this may be filled in with more
 * information about the error.
 */
typedef enum _Response__ErrorType {
  RESPONSE__ERROR_TYPE__INTERNAL = 1000000,
  RESPONSE__ERROR_TYPE__RESOURCE_LIMIT = 2000000,
  RESPONSE__ERROR_TYPE__QUERY_LOGIC = 3000000,
  RESPONSE__ERROR_TYPE__NON_EXISTENCE = 3100000,
  RESPONSE__ERROR_TYPE__OP_FAILED = 4100000,
  RESPONSE__ERROR_TYPE__OP_INDETERMINATE = 4200000,
  RESPONSE__ERROR_TYPE__USER = 5000000,
  RESPONSE__ERROR_TYPE__PERMISSION_ERROR = 6000000
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__ERROR_TYPE)
} Response__ErrorType;
/*
 * ResponseNotes are used to provide information about the query
 * response that may be useful for people writing drivers or ORMs.
 * Currently all the notes we send indicate that a stream has certain
 * special properties.
 */
typedef enum _Response__ResponseNote {
  /*
   * The stream is a changefeed stream (e.g. `r.table('test').changes()`).
   */
  RESPONSE__RESPONSE_NOTE__SEQUENCE_FEED = 1,
  /*
   * The stream is a point changefeed stream
   * (e.g. `r.table('test').get(0).changes()`).
   */
  RESPONSE__RESPONSE_NOTE__ATOM_FEED = 2,
  /*
   * The stream is an order_by_limit changefeed stream
   * (e.g. `r.table('test').order_by(index: 'id').limit(5).changes()`).
   */
  RESPONSE__RESPONSE_NOTE__ORDER_BY_LIMIT_FEED = 3,
  /*
   * The stream is a union of multiple changefeed types that can't be
   * collapsed to a single type
   * (e.g. `r.table('test').changes().union(r.table('test').get(0).changes())`).
   */
  RESPONSE__RESPONSE_NOTE__UNIONED_FEED = 4,
  /*
   * The stream is a changefeed stream and includes notes on what state
   * the changefeed stream is in (e.g. objects of the form `{state:
   * 'initializing'}`).
   */
  RESPONSE__RESPONSE_NOTE__INCLUDES_STATES = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(RESPONSE__RESPONSE_NOTE)
} Response__ResponseNote;
typedef enum _Datum__DatumType {
  DATUM__DATUM_TYPE__R_NULL = 1,
  DATUM__DATUM_TYPE__R_BOOL = 2,
  /*
   * a double
   */
  DATUM__DATUM_TYPE__R_NUM = 3,
  DATUM__DATUM_TYPE__R_STR = 4,
  DATUM__DATUM_TYPE__R_ARRAY = 5,
  DATUM__DATUM_TYPE__R_OBJECT = 6,
  /*
   * This [DatumType] will only be used if [accepts_r_json] is
   * set to [true] in [Query].  [r_str] will be filled with a
   * JSON encoding of the [Datum].
   */
  /*
   * uses r_str
   */
  DATUM__DATUM_TYPE__R_JSON = 7
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(DATUM__DATUM_TYPE)
} Datum__DatumType;
typedef enum _Term__TermType {
  /*
   * A RQL datum, stored in `datum` below.
   */
  TERM__TERM_TYPE__DATUM = 1,
  /*
   * DATUM... -> ARRAY
   */
  TERM__TERM_TYPE__MAKE_ARRAY = 2,
  /*
   * Evaluate the terms in [optargs] and make an object
   */
  /*
   * {...} -> OBJECT
   */
  TERM__TERM_TYPE__MAKE_OBJ = 3,
  /*
   * Takes an integer representing a variable and returns the value stored
   * in that variable.  It's the responsibility of the client to translate
   * from their local representation of a variable to a unique _non-negative_
   * integer for that variable.  (We do it this way instead of letting
   * clients provide variable names as strings to discourage
   * variable-capturing client libraries, and because it's more efficient
   * on the wire.)
   */
  /*
   * !NUMBER -> DATUM
   */
  TERM__TERM_TYPE__VAR = 10,
  /*
   * Takes some javascript code and executes it.
   */
  /*
   * STRING {timeout: !NUMBER} -> DATUM |
   */
  TERM__TERM_TYPE__JAVASCRIPT = 11,
  /*
   * STRING {timeout: !NUMBER} -> Function(*)
   */
  /*
   * () -> DATUM
   */
  TERM__TERM_TYPE__UUID = 169,
  /*
   * Takes an HTTP URL and gets it.  If the get succeeds and
   *  returns valid JSON, it is converted into a DATUM
   */
  /*
   * STRING {data: OBJECT | STRING,
   */
  TERM__TERM_TYPE__HTTP = 153,
  /*
   * Takes a string and throws an error with that message.
   * Inside of a `default` block, you can omit the first
   * argument to rethrow whatever error you catch (this is most
   * useful as an argument to the `default` filter optarg).
   */
  /*
   * STRING -> Error | -> Error
   */
  TERM__TERM_TYPE__ERROR = 12,
  /*
   * Takes nothing and returns a reference to the implicit variable.
   */
  /*
   * -> DATUM
   */
  TERM__TERM_TYPE__IMPLICIT_VAR = 13,
  /*
   * * Data Operators
   * Returns a reference to a database.
   */
  /*
   * STRING -> Database
   */
  TERM__TERM_TYPE__DB = 14,
  /*
   * Returns a reference to a table.
   */
  /*
   * Database, STRING, {read_mode:STRING, identifier_format:STRING} -> Table
   */
  TERM__TERM_TYPE__TABLE = 15,
  /*
   * STRING, {read_mode:STRING, identifier_format:STRING} -> Table
   * Gets a single element from a table by its primary or a secondary key.
   */
  /*
   * Table, STRING -> SingleSelection | Table, NUMBER -> SingleSelection |
   */
  TERM__TERM_TYPE__GET = 16,
  /*
   * Table, STRING -> NULL            | Table, NUMBER -> NULL |
   */
  /*
   * Table, DATUM..., {index:!STRING} => ARRAY
   */
  TERM__TERM_TYPE__GET_ALL = 78,
  /*
   * Simple DATUM Ops
   */
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__EQ = 17,
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__NE = 18,
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__LT = 19,
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__LE = 20,
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__GT = 21,
  /*
   * DATUM... -> BOOL
   */
  TERM__TERM_TYPE__GE = 22,
  /*
   * BOOL -> BOOL
   */
  TERM__TERM_TYPE__NOT = 23,
  /*
   * ADD can either add two numbers or concatenate two arrays.
   */
  /*
   * NUMBER... -> NUMBER | STRING... -> STRING
   */
  TERM__TERM_TYPE__ADD = 24,
  /*
   * NUMBER... -> NUMBER
   */
  TERM__TERM_TYPE__SUB = 25,
  /*
   * NUMBER... -> NUMBER
   */
  TERM__TERM_TYPE__MUL = 26,
  /*
   * NUMBER... -> NUMBER
   */
  TERM__TERM_TYPE__DIV = 27,
  /*
   * NUMBER, NUMBER -> NUMBER
   */
  TERM__TERM_TYPE__MOD = 28,
  /*
   * NUMBER -> NUMBER
   */
  TERM__TERM_TYPE__FLOOR = 183,
  /*
   * NUMBER -> NUMBER
   */
  TERM__TERM_TYPE__CEIL = 184,
  /*
   * NUMBER -> NUMBER
   */
  TERM__TERM_TYPE__ROUND = 185,
  /*
   * DATUM Array Ops
   * Append a single element to the end of an array (like `snoc`).
   */
  /*
   * ARRAY, DATUM -> ARRAY
   */
  TERM__TERM_TYPE__APPEND = 29,
  /*
   * Prepend a single element to the end of an array (like `cons`).
   */
  /*
   * ARRAY, DATUM -> ARRAY
   */
  TERM__TERM_TYPE__PREPEND = 80,
  /*
   *Remove the elements of one array from another array.
   */
  /*
   * ARRAY, ARRAY -> ARRAY
   */
  TERM__TERM_TYPE__DIFFERENCE = 95,
  /*
   * DATUM Set Ops
   * Set ops work on arrays. They don't use actual sets and thus have
   * performance characteristics you would expect from arrays rather than
   * from sets. All set operations have the post condition that they
   * array they return contains no duplicate values.
   */
  /*
   * ARRAY, DATUM -> ARRAY
   */
  TERM__TERM_TYPE__SET_INSERT = 88,
  /*
   * ARRAY, ARRAY -> ARRAY
   */
  TERM__TERM_TYPE__SET_INTERSECTION = 89,
  /*
   * ARRAY, ARRAY -> ARRAY
   */
  TERM__TERM_TYPE__SET_UNION = 90,
  /*
   * ARRAY, ARRAY -> ARRAY
   */
  TERM__TERM_TYPE__SET_DIFFERENCE = 91,
  /*
   * Sequence, NUMBER, NUMBER -> Sequence
   */
  TERM__TERM_TYPE__SLICE = 30,
  /*
   * Sequence, NUMBER -> Sequence
   */
  TERM__TERM_TYPE__SKIP = 70,
  /*
   * Sequence, NUMBER -> Sequence
   */
  TERM__TERM_TYPE__LIMIT = 71,
  /*
   * Sequence, DATUM -> Sequence | Sequence, Function(1) -> Sequence
   */
  TERM__TERM_TYPE__OFFSETS_OF = 87,
  /*
   * Sequence, (DATUM | Function(1))... -> BOOL
   */
  TERM__TERM_TYPE__CONTAINS = 93,
  /*
   * Stream/Object Ops
   * Get a particular field from an object, or map that over a
   * sequence.
   */
  /*
   * OBJECT, STRING -> DATUM
   */
  TERM__TERM_TYPE__GET_FIELD = 31,
  /*
   * | Sequence, STRING -> Sequence
   * Return an array containing the keys of the object.
   */
  /*
   * OBJECT -> ARRAY
   */
  TERM__TERM_TYPE__KEYS = 94,
  /*
   * Return an array containing the values of the object.
   */
  /*
   * OBJECT -> ARRAY
   */
  TERM__TERM_TYPE__VALUES = 186,
  /*
   * Creates an object
   */
  /*
   * STRING, DATUM, ... -> OBJECT
   */
  TERM__TERM_TYPE__OBJECT = 143,
  /*
   * Check whether an object contains all the specified fields,
   * or filters a sequence so that all objects inside of it
   * contain all the specified fields.
   */
  /*
   * OBJECT, Pathspec... -> BOOL
   */
  TERM__TERM_TYPE__HAS_FIELDS = 32,
  /*
   * x.with_fields(...) <=> x.has_fields(...).pluck(...)
   */
  /*
   * Sequence, Pathspec... -> Sequence
   */
  TERM__TERM_TYPE__WITH_FIELDS = 96,
  /*
   * Get a subset of an object by selecting some attributes to preserve,
   * or map that over a sequence.  (Both pick and pluck, polymorphic.)
   */
  /*
   * Sequence, Pathspec... -> Sequence | OBJECT, Pathspec... -> OBJECT
   */
  TERM__TERM_TYPE__PLUCK = 33,
  /*
   * Get a subset of an object by selecting some attributes to discard, or
   * map that over a sequence.  (Both unpick and without, polymorphic.)
   */
  /*
   * Sequence, Pathspec... -> Sequence | OBJECT, Pathspec... -> OBJECT
   */
  TERM__TERM_TYPE__WITHOUT = 34,
  /*
   * Merge objects (right-preferential)
   */
  /*
   * OBJECT... -> OBJECT | Sequence -> Sequence
   */
  TERM__TERM_TYPE__MERGE = 35,
  /*
   * Sequence Ops
   * Get all elements of a sequence between two values.
   * Half-open by default, but the openness of either side can be
   * changed by passing 'closed' or 'open for `right_bound` or
   * `left_bound`.
   */
  /*
   * Deprecated version of between, which allows `null` to specify unboundedness
   */
  TERM__TERM_TYPE__BETWEEN_DEPRECATED = 36,
  /*
   * With the newer version, clients should use `r.minval` and `r.maxval` for unboundedness
   */
  /*
   * StreamSelection, DATUM, DATUM, {index:!STRING, right_bound:STRING, left_bound:STRING} -> StreamSelection
   */
  TERM__TERM_TYPE__BETWEEN = 182,
  /*
   * Sequence, Function(2) -> DATUM
   */
  TERM__TERM_TYPE__REDUCE = 37,
  /*
   * Sequence, Function(1) -> Sequence
   */
  TERM__TERM_TYPE__MAP = 38,
  /*
   * Sequence, Datum, Function(2), {Function(3), Function(1)
   */
  TERM__TERM_TYPE__FOLD = 187,
  /*
   * Filter a sequence with either a function or a shortcut
   * object (see API docs for details).  The body of FILTER is
   * wrapped in an implicit `.default(false)`, and you can
   * change the default value by specifying the `default`
   * optarg.  If you make the default `r.error`, all errors
   * caught by `default` will be rethrown as if the `default`
   * did not exist.
   */
  /*
   * Sequence, Function(1), {default:DATUM} -> Sequence |
   */
  TERM__TERM_TYPE__FILTER = 39,
  /*
   * Sequence, OBJECT, {default:DATUM} -> Sequence
   * Map a function over a sequence and then concatenate the results together.
   */
  /*
   * Sequence, Function(1) -> Sequence
   */
  TERM__TERM_TYPE__CONCAT_MAP = 40,
  /*
   * Order a sequence based on one or more attributes.
   */
  /*
   * Sequence, (!STRING | Ordering)..., {index: (!STRING | Ordering)} -> Sequence
   */
  TERM__TERM_TYPE__ORDER_BY = 41,
  /*
   * Get all distinct elements of a sequence (like `uniq`).
   */
  /*
   * Sequence -> Sequence
   */
  TERM__TERM_TYPE__DISTINCT = 42,
  /*
   * Count the number of elements in a sequence, or only the elements that match
   * a given filter.
   */
  /*
   * Sequence -> NUMBER | Sequence, DATUM -> NUMBER | Sequence, Function(1) -> NUMBER
   */
  TERM__TERM_TYPE__COUNT = 43,
  /*
   * Sequence -> BOOL
   */
  TERM__TERM_TYPE__IS_EMPTY = 86,
  /*
   * Take the union of multiple sequences (preserves duplicate elements! (use distinct)).
   */
  /*
   * Sequence... -> Sequence
   */
  TERM__TERM_TYPE__UNION = 44,
  /*
   * Get the Nth element of a sequence.
   */
  /*
   * Sequence, NUMBER -> DATUM
   */
  TERM__TERM_TYPE__NTH = 45,
  /*
   * do NTH or GET_FIELD depending on target object
   */
  /*
   * Sequence | OBJECT, NUMBER | STRING -> DATUM
   */
  TERM__TERM_TYPE__BRACKET = 170,
  /*
   * Sequence, Sequence, Function(2) -> Sequence
   */
  TERM__TERM_TYPE__INNER_JOIN = 48,
  /*
   * Sequence, Sequence, Function(2) -> Sequence
   */
  TERM__TERM_TYPE__OUTER_JOIN = 49,
  /*
   * An inner-join that does an equality comparison on two attributes.
   */
  /*
   * Sequence, !STRING, Sequence, {index:!STRING} -> Sequence
   */
  TERM__TERM_TYPE__EQ_JOIN = 50,
  /*
   * Sequence -> Sequence
   */
  TERM__TERM_TYPE__ZIP = 72,
  /*
   * -> Sequence                        [0, +inf)
   */
  TERM__TERM_TYPE__RANGE = 173,
  /*
   * Array Ops
   * Insert an element in to an array at a given index.
   */
  /*
   * ARRAY, NUMBER, DATUM -> ARRAY
   */
  TERM__TERM_TYPE__INSERT_AT = 82,
  /*
   * Remove an element at a given index from an array.
   */
  /*
   * ARRAY, NUMBER -> ARRAY |
   */
  TERM__TERM_TYPE__DELETE_AT = 83,
  /*
   * ARRAY, NUMBER, NUMBER -> ARRAY
   * Change the element at a given index of an array.
   */
  /*
   * ARRAY, NUMBER, DATUM -> ARRAY
   */
  TERM__TERM_TYPE__CHANGE_AT = 84,
  /*
   * Splice one array in to another array.
   */
  /*
   * ARRAY, NUMBER, ARRAY -> ARRAY
   */
  TERM__TERM_TYPE__SPLICE_AT = 85,
  /*
   * * Type Ops
   * Coerces a datum to a named type (e.g. "bool").
   * If you previously used `stream_to_array`, you should use this instead
   * with the type "array".
   */
  /*
   * Top, STRING -> Top
   */
  TERM__TERM_TYPE__COERCE_TO = 51,
  /*
   * Returns the named type of a datum (e.g. TYPE_OF(true) = "BOOL")
   */
  /*
   * Top -> STRING
   */
  TERM__TERM_TYPE__TYPE_OF = 52,
  /*
   * * Write Ops (the OBJECTs contain data about number of errors etc.)
   * Updates all the rows in a selection.  Calls its Function with the row
   * to be updated, and then merges the result of that call.
   */
  /*
   * StreamSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
   */
  TERM__TERM_TYPE__UPDATE = 53,
  /*
   * SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
   * StreamSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT |
   * SingleSelection, OBJECT,      {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
   * Deletes all the rows in a selection.
   */
  /*
   * StreamSelection, {durability:STRING, return_changes:BOOL} -> OBJECT | SingleSelection -> OBJECT
   */
  TERM__TERM_TYPE__DELETE = 54,
  /*
   * Replaces all the rows in a selection.  Calls its Function with the row
   * to be replaced, and then discards it and stores the result of that
   * call.
   */
  /*
   * StreamSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT | SingleSelection, Function(1), {non_atomic:BOOL, durability:STRING, return_changes:BOOL} -> OBJECT
   */
  TERM__TERM_TYPE__REPLACE = 55,
  /*
   * Inserts into a table.  If `conflict` is replace, overwrites
   * entries with the same primary key.  If `conflict` is
   * update, does an update on the entry.  If `conflict` is
   * error, or is omitted, conflicts will trigger an error.
   */
  /*
   * Table, OBJECT, {conflict:STRING, durability:STRING, return_changes:BOOL} -> OBJECT | Table, Sequence, {conflict:STRING, durability:STRING, return_changes:BOOL} -> OBJECT
   */
  TERM__TERM_TYPE__INSERT = 56,
  /*
   * * Administrative OPs
   * Creates a database with a particular name.
   */
  /*
   * STRING -> OBJECT
   */
  TERM__TERM_TYPE__DB_CREATE = 57,
  /*
   * Drops a database with a particular name.
   */
  /*
   * STRING -> OBJECT
   */
  TERM__TERM_TYPE__DB_DROP = 58,
  /*
   * Lists all the databases by name.  (Takes no arguments)
   */
  /*
   * -> ARRAY
   */
  TERM__TERM_TYPE__DB_LIST = 59,
  /*
   * Creates a table with a particular name in a particular
   * database.  (You may omit the first argument to use the
   * default database.)
   */
  /*
   * Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
   */
  TERM__TERM_TYPE__TABLE_CREATE = 60,
  /*
   * Database, STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
   * STRING, {primary_key:STRING, shards:NUMBER, replicas:NUMBER, primary_replica_tag:STRING} -> OBJECT
   * STRING, {primary_key:STRING, shards:NUMBER, replicas:OBJECT, primary_replica_tag:STRING} -> OBJECT
   * Drops a table with a particular name from a particular
   * database.  (You may omit the first argument to use the
   * default database.)
   */
  /*
   * Database, STRING -> OBJECT
   */
  TERM__TERM_TYPE__TABLE_DROP = 61,
  /*
   * STRING -> OBJECT
   * Lists all the tables in a particular database.  (You may
   * omit the first argument to use the default database.)
   */
  /*
   * Database -> ARRAY
   */
  TERM__TERM_TYPE__TABLE_LIST = 62,
  /*
   *  -> ARRAY
   * Returns the row in the `rethinkdb.table_config` or `rethinkdb.db_config` table
   * that corresponds to the given database or table.
   */
  /*
   * Database -> SingleSelection
   */
  TERM__TERM_TYPE__CONFIG = 174,
  /*
   * Table -> SingleSelection
   * Returns the row in the `rethinkdb.table_status` table that corresponds to the
   * given table.
   */
  /*
   * Table -> SingleSelection
   */
  TERM__TERM_TYPE__STATUS = 175,
  /*
   * Called on a table, waits for that table to be ready for read/write operations.
   * Called on a database, waits for all of the tables in the database to be ready.
   * Returns the corresponding row or rows from the `rethinkdb.table_status` table.
   */
  /*
   * Table -> OBJECT
   */
  TERM__TERM_TYPE__WAIT = 177,
  /*
   * Database -> OBJECT
   * Generates a new config for the given table, or all tables in the given database
   * The `shards` and `replicas` arguments are required. If `emergency_repair` is
   * specified, it will enter a completely different mode of repairing a table
   * which has lost half or more of its replicas.
   */
  /*
   * Database|Table, {shards:NUMBER, replicas:NUMBER [,
   */
  TERM__TERM_TYPE__RECONFIGURE = 176,
  /*
   *                  dry_run:BOOLEAN]
   *                 } -> OBJECT
   * Database|Table, {shards:NUMBER, replicas:OBJECT [,
   *                  primary_replica_tag:STRING,
   *                  nonvoting_replica_tags:ARRAY,
   *                  dry_run:BOOLEAN]
   *                 } -> OBJECT
   * Table, {emergency_repair:STRING, dry_run:BOOLEAN} -> OBJECT
   * Balances the table's shards but leaves everything else the same. Can also be
   * applied to an entire database at once.
   */
  /*
   * Table -> OBJECT
   */
  TERM__TERM_TYPE__REBALANCE = 179,
  /*
   * Ensures that previously issued soft-durability writes are complete and
   * written to disk.
   */
  /*
   * Table -> OBJECT
   */
  TERM__TERM_TYPE__SYNC = 138,
  /*
   * Set global, database, or table-specific permissions
   */
  /*
   *          -> OBJECT
   */
  TERM__TERM_TYPE__GRANT = 188,
  /*
   * * Secondary indexes OPs
   * Creates a new secondary index with a particular name and definition.
   */
  /*
   * Table, STRING, Function(1), {multi:BOOL} -> OBJECT
   */
  TERM__TERM_TYPE__INDEX_CREATE = 75,
  /*
   * Drops a secondary index with a particular name from the specified table.
   */
  /*
   * Table, STRING -> OBJECT
   */
  TERM__TERM_TYPE__INDEX_DROP = 76,
  /*
   * Lists all secondary indexes on a particular table.
   */
  /*
   * Table -> ARRAY
   */
  TERM__TERM_TYPE__INDEX_LIST = 77,
  /*
   * Gets information about whether or not a set of indexes are ready to
   * be accessed. Returns a list of objects that look like this:
   * {index:STRING, ready:BOOL[, progress:NUMBER]}
   */
  /*
   * Table, STRING... -> ARRAY
   */
  TERM__TERM_TYPE__INDEX_STATUS = 139,
  /*
   * Blocks until a set of indexes are ready to be accessed. Returns the
   * same values INDEX_STATUS.
   */
  /*
   * Table, STRING... -> ARRAY
   */
  TERM__TERM_TYPE__INDEX_WAIT = 140,
  /*
   * Renames the given index to a new name
   */
  /*
   * Table, STRING, STRING, {overwrite:BOOL} -> OBJECT
   */
  TERM__TERM_TYPE__INDEX_RENAME = 156,
  /*
   * * Write hook Function OPs
   * Creates a new write hook function with a particular definition
   */
  /*
   * Table, Function(2)
   */
  TERM__TERM_TYPE__SET_WRITE_HOOK = 189,
  /*
   * Gets an existing write hook function on a table
   */
  /*
   * Table
   */
  TERM__TERM_TYPE__GET_WRITE_HOOK = 190,
  /*
   * * Control Operators
   * Calls a function on data
   */
  /*
   * Function(*), DATUM... -> DATUM
   */
  TERM__TERM_TYPE__FUNCALL = 64,
  /*
   * Executes its first argument, and returns its second argument if it
   * got [true] or its third argument if it got [false] (like an `if`
   * statement).
   */
  /*
   * BOOL, Top, Top -> Top
   */
  TERM__TERM_TYPE__BRANCH = 65,
  /*
   * Returns true if any of its arguments returns true (short-circuits).
   */
  /*
   * BOOL... -> BOOL
   */
  TERM__TERM_TYPE__OR = 66,
  /*
   * Returns true if all of its arguments return true (short-circuits).
   */
  /*
   * BOOL... -> BOOL
   */
  TERM__TERM_TYPE__AND = 67,
  /*
   * Calls its Function with each entry in the sequence
   * and executes the array of terms that Function returns.
   */
  /*
   * Sequence, Function(1) -> OBJECT
   */
  TERM__TERM_TYPE__FOR_EACH = 68,
  /*
   * An anonymous function.  Takes an array of numbers representing
   * variables (see [VAR] above), and a [Term] to execute with those in
   * scope.  Returns a function that may be passed an array of arguments,
   * then executes the Term with those bound to the variable names.  The
   * user will never construct this directly.  We use it internally for
   * things like `map` which take a function.  The "arity" of a [Function] is
   * the number of arguments it takes.
   * For example, here's what `_X_.map{|x| x+2}` turns into:
   * Term {
   *   type = MAP;
   *   args = [_X_,
   *           Term {
   *             type = Function;
   *             args = [Term {
   *                       type = DATUM;
   *                       datum = Datum {
   *                         type = R_ARRAY;
   *                         r_array = [Datum { type = R_NUM; r_num = 1; }];
   *                       };
   *                     },
   *                     Term {
   *                       type = ADD;
   *                       args = [Term {
   *                                 type = VAR;
   *                                 args = [Term {
   *                                           type = DATUM;
   *                                           datum = Datum { type = R_NUM;
   *                                                           r_num = 1};
   *                                         }];
   *                               },
   *                               Term {
   *                                 type = DATUM;
   *                                 datum = Datum { type = R_NUM; r_num = 2; };
   *                               }];
   *                     }];
   *           }];
   */
  /*
   * ARRAY, Top -> ARRAY -> Top
   */
  TERM__TERM_TYPE__FUNC = 69,
  /*
   * Indicates to ORDER_BY that this attribute is to be sorted in ascending order.
   */
  /*
   * !STRING -> Ordering
   */
  TERM__TERM_TYPE__ASC = 73,
  /*
   * Indicates to ORDER_BY that this attribute is to be sorted in descending order.
   */
  /*
   * !STRING -> Ordering
   */
  TERM__TERM_TYPE__DESC = 74,
  /*
   * Gets info about anything.  INFO is most commonly called on tables.
   */
  /*
   * Top -> OBJECT
   */
  TERM__TERM_TYPE__INFO = 79,
  /*
   * `a.match(b)` returns a match object if the string `a`
   * matches the regular expression `b`.
   */
  /*
   * STRING, STRING -> DATUM
   */
  TERM__TERM_TYPE__MATCH = 97,
  /*
   * Change the case of a string.
   */
  /*
   * STRING -> STRING
   */
  TERM__TERM_TYPE__UPCASE = 141,
  /*
   * STRING -> STRING
   */
  TERM__TERM_TYPE__DOWNCASE = 142,
  /*
   * Select a number of elements from sequence with uniform distribution.
   */
  /*
   * Sequence, NUMBER -> Sequence
   */
  TERM__TERM_TYPE__SAMPLE = 81,
  /*
   * Evaluates its first argument.  If that argument returns
   * NULL or throws an error related to the absence of an
   * expected value (for instance, accessing a non-existent
   * field or adding NULL to an integer), DEFAULT will either
   * return its second argument or execute it if it's a
   * function.  If the second argument is a function, it will be
   * passed either the text of the error or NULL as its
   * argument.
   */
  /*
   * Top, Top -> Top
   */
  TERM__TERM_TYPE__DEFAULT = 92,
  /*
   * Parses its first argument as a json string and returns it as a
   * datum.
   */
  /*
   * STRING -> DATUM
   */
  TERM__TERM_TYPE__JSON = 98,
  /*
   * Parses its first arguments as an ISO 8601 time and returns it as a
   * datum.
   */
  /*
   * STRING -> PSEUDOTYPE(TIME)
   */
  TERM__TERM_TYPE__ISO8601 = 99,
  /*
   * Prints a time as an ISO 8601 time.
   */
  /*
   * PSEUDOTYPE(TIME) -> STRING
   */
  TERM__TERM_TYPE__TO_ISO8601 = 100,
  /*
   * Returns a time given seconds since epoch in UTC.
   */
  /*
   * NUMBER -> PSEUDOTYPE(TIME)
   */
  TERM__TERM_TYPE__EPOCH_TIME = 101,
  /*
   * Returns seconds since epoch in UTC given a time.
   */
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__TO_EPOCH_TIME = 102,
  /*
   * The time the query was received by the server.
   */
  /*
   * -> PSEUDOTYPE(TIME)
   */
  TERM__TERM_TYPE__NOW = 103,
  /*
   * Puts a time into an ISO 8601 timezone.
   */
  /*
   * PSEUDOTYPE(TIME), STRING -> PSEUDOTYPE(TIME)
   */
  TERM__TERM_TYPE__IN_TIMEZONE = 104,
  /*
   * a.during(b, c) returns whether a is in the range [b, c)
   */
  /*
   * PSEUDOTYPE(TIME), PSEUDOTYPE(TIME), PSEUDOTYPE(TIME) -> BOOL
   */
  TERM__TERM_TYPE__DURING = 105,
  /*
   * Retrieves the date portion of a time.
   */
  /*
   * PSEUDOTYPE(TIME) -> PSEUDOTYPE(TIME)
   */
  TERM__TERM_TYPE__DATE = 106,
  /*
   * x.time_of_day == x.date - x
   */
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__TIME_OF_DAY = 126,
  /*
   * Returns the timezone of a time.
   */
  /*
   * PSEUDOTYPE(TIME) -> STRING
   */
  TERM__TERM_TYPE__TIMEZONE = 127,
  /*
   * These access the various components of a time.
   */
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__YEAR = 128,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__MONTH = 129,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__DAY = 130,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__DAY_OF_WEEK = 131,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__DAY_OF_YEAR = 132,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__HOURS = 133,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__MINUTES = 134,
  /*
   * PSEUDOTYPE(TIME) -> NUMBER
   */
  TERM__TERM_TYPE__SECONDS = 135,
  /*
   * Construct a time from a date and optional timezone or a
   * date+time and optional timezone.
   */
  /*
   * NUMBER, NUMBER, NUMBER, STRING -> PSEUDOTYPE(TIME) |
   */
  TERM__TERM_TYPE__TIME = 136,
  /*
   * Constants for ISO 8601 days of the week.
   */
  /*
   * -> 1
   */
  TERM__TERM_TYPE__MONDAY = 107,
  /*
   * -> 2
   */
  TERM__TERM_TYPE__TUESDAY = 108,
  /*
   * -> 3
   */
  TERM__TERM_TYPE__WEDNESDAY = 109,
  /*
   * -> 4
   */
  TERM__TERM_TYPE__THURSDAY = 110,
  /*
   * -> 5
   */
  TERM__TERM_TYPE__FRIDAY = 111,
  /*
   * -> 6
   */
  TERM__TERM_TYPE__SATURDAY = 112,
  /*
   * -> 7
   */
  TERM__TERM_TYPE__SUNDAY = 113,
  /*
   * Constants for ISO 8601 months.
   */
  /*
   * -> 1
   */
  TERM__TERM_TYPE__JANUARY = 114,
  /*
   * -> 2
   */
  TERM__TERM_TYPE__FEBRUARY = 115,
  /*
   * -> 3
   */
  TERM__TERM_TYPE__MARCH = 116,
  /*
   * -> 4
   */
  TERM__TERM_TYPE__APRIL = 117,
  /*
   * -> 5
   */
  TERM__TERM_TYPE__MAY = 118,
  /*
   * -> 6
   */
  TERM__TERM_TYPE__JUNE = 119,
  /*
   * -> 7
   */
  TERM__TERM_TYPE__JULY = 120,
  /*
   * -> 8
   */
  TERM__TERM_TYPE__AUGUST = 121,
  /*
   * -> 9
   */
  TERM__TERM_TYPE__SEPTEMBER = 122,
  /*
   * -> 10
   */
  TERM__TERM_TYPE__OCTOBER = 123,
  /*
   * -> 11
   */
  TERM__TERM_TYPE__NOVEMBER = 124,
  /*
   * -> 12
   */
  TERM__TERM_TYPE__DECEMBER = 125,
  /*
   * Indicates to MERGE to replace, or remove in case of an empty literal, the
   * other object rather than merge it.
   */
  /*
   * -> Merging
   */
  TERM__TERM_TYPE__LITERAL = 137,
  /*
   * SEQUENCE, STRING -> GROUPED_SEQUENCE | SEQUENCE, FUNCTION -> GROUPED_SEQUENCE
   */
  TERM__TERM_TYPE__GROUP = 144,
  TERM__TERM_TYPE__SUM = 145,
  TERM__TERM_TYPE__AVG = 146,
  TERM__TERM_TYPE__MIN = 147,
  TERM__TERM_TYPE__MAX = 148,
  /*
   * `str.split()` splits on whitespace
   * `str.split(" ")` splits on spaces only
   * `str.split(" ", 5)` splits on spaces with at most 5 results
   * `str.split(nil, 5)` splits on whitespace with at most 5 results
   */
  /*
   * STRING -> ARRAY | STRING, STRING -> ARRAY | STRING, STRING, NUMBER -> ARRAY | STRING, NULL, NUMBER -> ARRAY
   */
  TERM__TERM_TYPE__SPLIT = 149,
  /*
   * GROUPED_DATA -> ARRAY
   */
  TERM__TERM_TYPE__UNGROUP = 150,
  /*
   * Takes a range of numbers and returns a random number within the range
   */
  /*
   * NUMBER, NUMBER {float:BOOL} -> DATUM
   */
  TERM__TERM_TYPE__RANDOM = 151,
  /*
   * TABLE -> STREAM
   */
  TERM__TERM_TYPE__CHANGES = 152,
  /*
   * ARRAY -> SPECIAL (used to splice arguments)
   */
  TERM__TERM_TYPE__ARGS = 154,
  /*
   * BINARY is client-only at the moment, it is not supported on the server
   */
  /*
   * STRING -> PSEUDOTYPE(BINARY)
   */
  TERM__TERM_TYPE__BINARY = 155,
  /*
   * OBJECT -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__GEOJSON = 157,
  /*
   * PSEUDOTYPE(GEOMETRY) -> OBJECT
   */
  TERM__TERM_TYPE__TO_GEOJSON = 158,
  /*
   * NUMBER, NUMBER -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__POINT = 159,
  /*
   * (ARRAY | PSEUDOTYPE(GEOMETRY))... -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__LINE = 160,
  /*
   * (ARRAY | PSEUDOTYPE(GEOMETRY))... -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__POLYGON = 161,
  /*
   * PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) {geo_system:STRING, unit:STRING} -> NUMBER
   */
  TERM__TERM_TYPE__DISTANCE = 162,
  /*
   * PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> BOOL
   */
  TERM__TERM_TYPE__INTERSECTS = 163,
  /*
   * PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> BOOL
   */
  TERM__TERM_TYPE__INCLUDES = 164,
  /*
   * PSEUDOTYPE(GEOMETRY), NUMBER {num_vertices:NUMBER, geo_system:STRING, unit:STRING, fill:BOOL} -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__CIRCLE = 165,
  /*
   * TABLE, PSEUDOTYPE(GEOMETRY) {index:!STRING} -> StreamSelection
   */
  TERM__TERM_TYPE__GET_INTERSECTING = 166,
  /*
   * PSEUDOTYPE(GEOMETRY) -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__FILL = 167,
  /*
   * TABLE, PSEUDOTYPE(GEOMETRY) {index:!STRING, max_results:NUM, max_dist:NUM, geo_system:STRING, unit:STRING} -> ARRAY
   */
  TERM__TERM_TYPE__GET_NEAREST = 168,
  /*
   * PSEUDOTYPE(GEOMETRY), PSEUDOTYPE(GEOMETRY) -> PSEUDOTYPE(GEOMETRY)
   */
  TERM__TERM_TYPE__POLYGON_SUB = 171,
  /*
   * Returns the datum as a JSON string.
   * N.B.: we would really prefer this be named TO_JSON and that exists as
   * an alias in Python and JavaScript drivers; however it conflicts with the
   * standard `to_json` method defined by Ruby's standard json library.
   */
  /*
   * DATUM -> STRING
   */
  TERM__TERM_TYPE__TO_JSON_STRING = 172,
  /*
   * Constants for specifying key ranges
   */
  TERM__TERM_TYPE__MINVAL = 180,
  TERM__TERM_TYPE__MAXVAL = 181,
  /*
   * Bitwise operations
   */
  TERM__TERM_TYPE__BIT_AND = 191,
  TERM__TERM_TYPE__BIT_OR = 192,
  TERM__TERM_TYPE__BIT_XOR = 193,
  TERM__TERM_TYPE__BIT_NOT = 194,
  TERM__TERM_TYPE__BIT_SAL = 195,
  TERM__TERM_TYPE__BIT_SAR = 196
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(TERM__TERM_TYPE)
} Term__TermType;

/* --- messages --- */

struct  _VersionDummy
{
  ProtobufCMessage base;
};
#define VERSION_DUMMY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&version_dummy__descriptor) \
     }


struct  _Query__AssocPair
{
  ProtobufCMessage base;
  char *key;
  Term *val;
};
#define QUERY__ASSOC_PAIR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&query__assoc_pair__descriptor) \
    , NULL, NULL }


/*
 * You send one of:
 * * A [START] query with a [Term] to evaluate and a unique-per-connection token.
 * * A [CONTINUE] query with the same token as a [START] query that returned
 *   [SUCCESS_PARTIAL] in its [Response].
 * * A [STOP] query with the same token as a [START] query that you want to stop.
 * * A [NOREPLY_WAIT] query with a unique per-connection token. The server answers
 *   with a [WAIT_COMPLETE] [Response].
 * * A [SERVER_INFO] query. The server answers with a [SERVER_INFO] [Response].
 */
struct  _Query
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  Query__QueryType type;
  /*
   * A [Term] is how we represent the operations we want a query to perform.
   */
  /*
   * only present when [type] = [START]
   */
  Term *query;
  protobuf_c_boolean has_token;
  int64_t token;
  /*
   * This flag is ignored on the server.  `noreply` should be added
   * to `global_optargs` instead (the key "noreply" should map to
   * either true or false).
   */
  protobuf_c_boolean has_obsolete_noreply;
  protobuf_c_boolean obsolete_noreply;
  /*
   * If this is set to [true], then [Datum] values will sometimes be
   * of [DatumType] [R_JSON] (see below).  This can provide enormous
   * speedups in languages with poor protobuf libraries.
   */
  protobuf_c_boolean has_accepts_r_json;
  protobuf_c_boolean accepts_r_json;
  size_t n_global_optargs;
  Query__AssocPair **global_optargs;
};
#define QUERY__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&query__descriptor) \
    , 0, QUERY__QUERY_TYPE__START, NULL, 0, 0, 0, 0, 0, 0, 0,NULL }


/*
 * A backtrace frame (see `backtrace` in Response below)
 */
struct  _Frame
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  Frame__FrameType type;
  /*
   * The index of the positional argument.
   */
  protobuf_c_boolean has_pos;
  int64_t pos;
  /*
   * The name of the optional argument.
   */
  char *opt;
};
#define FRAME__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&frame__descriptor) \
    , 0, FRAME__FRAME_TYPE__POS, 0, 0, NULL }


struct  _Backtrace
{
  ProtobufCMessage base;
  size_t n_frames;
  Frame **frames;
};
#define BACKTRACE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&backtrace__descriptor) \
    , 0,NULL }


/*
 * You get back a response with the same [token] as your query.
 */
struct  _Response
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  Response__ResponseType type;
  protobuf_c_boolean has_error_type;
  Response__ErrorType error_type;
  size_t n_notes;
  Response__ResponseNote *notes;
  /*
   * Indicates what [Query] this response corresponds to.
   */
  protobuf_c_boolean has_token;
  int64_t token;
  /*
   * [response] contains 1 RQL datum if [type] is [SUCCESS_ATOM] or
   * [SERVER_INFO].  [response] contains many RQL data if [type] is
   * [SUCCESS_SEQUENCE] or [SUCCESS_PARTIAL].  [response] contains 1
   * error message (of type [R_STR]) in all other cases.
   */
  size_t n_response;
  Datum **response;
  /*
   * If [type] is [CLIENT_ERROR], [TYPE_ERROR], or [RUNTIME_ERROR], then a
   * backtrace will be provided.  The backtrace says where in the query the
   * error occurred.  Ideally this information will be presented to the user as
   * a pretty-printed version of their query with the erroneous section
   * underlined.  A backtrace is a series of 0 or more [Frame]s, each of which
   * specifies either the index of a positional argument or the name of an
   * optional argument.  (Those words will make more sense if you look at the
   * [Term] message below.)
   */
  /*
   * Contains n [Frame]s when you get back an error.
   */
  Backtrace *backtrace;
  /*
   * If the [global_optargs] in the [Query] that this [Response] is a
   * response to contains a key "profile" which maps to a static value of
   * true then [profile] will contain a [Datum] which provides profiling
   * information about the execution of the query. This field should be
   * returned to the user along with the result that would normally be
   * returned (a datum or a cursor). In official drivers this is accomplished
   * by putting them inside of an object with "value" mapping to the return
   * value and "profile" mapping to the profile object.
   */
  Datum *profile;
};
#define RESPONSE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&response__descriptor) \
    , 0, RESPONSE__RESPONSE_TYPE__SUCCESS_ATOM, 0, RESPONSE__ERROR_TYPE__INTERNAL, 0,NULL, 0, 0, 0,NULL, NULL, NULL }


struct  _Datum__AssocPair
{
  ProtobufCMessage base;
  char *key;
  Datum *val;
};
#define DATUM__ASSOC_PAIR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&datum__assoc_pair__descriptor) \
    , NULL, NULL }


/*
 * A [Datum] is a chunk of data that can be serialized to disk or returned to
 * the user in a Response.  Currently we only support JSON types, but we may
 * support other types in the future (e.g., a date type or an integer type).
 */
struct  _Datum
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  Datum__DatumType type;
  protobuf_c_boolean has_r_bool;
  protobuf_c_boolean r_bool;
  protobuf_c_boolean has_r_num;
  double r_num;
  char *r_str;
  size_t n_r_array;
  Datum **r_array;
  size_t n_r_object;
  Datum__AssocPair **r_object;
};
#define DATUM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&datum__descriptor) \
    , 0, DATUM__DATUM_TYPE__R_NULL, 0, 0, 0, 0, NULL, 0,NULL, 0,NULL }


struct  _Term__AssocPair
{
  ProtobufCMessage base;
  char *key;
  Term *val;
};
#define TERM__ASSOC_PAIR__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&term__assoc_pair__descriptor) \
    , NULL, NULL }


/*
 * A [Term] is either a piece of data (see **Datum** above), or an operator and
 * its operands.  If you have a [Datum], it's stored in the member [datum].  If
 * you have an operator, its positional arguments are stored in [args] and its
 * optional arguments are stored in [optargs].
 * A note about type signatures:
 * We use the following notation to denote types:
 *   arg1_type, arg2_type, argrest_type... -> result_type
 * So, for example, if we have a function `avg` that takes any number of
 * arguments and averages them, we might write:
 *   NUMBER... -> NUMBER
 * Or if we had a function that took one number modulo another:
 *   NUMBER, NUMBER -> NUMBER
 * Or a function that takes a table and a primary key of any Datum type, then
 * retrieves the entry with that primary key:
 *   Table, DATUM -> OBJECT
 * Some arguments must be provided as literal values (and not the results of sub
 * terms).  These are marked with a `!`.
 * Optional arguments are specified within curly braces as argname `:` value
 * type (e.x `{noreply:BOOL}`)
 * Many RQL operations are polymorphic. For these, alterantive type signatures
 * are separated by `|`.
 * The RQL type hierarchy is as follows:
 *   Top
 *     DATUM
 *       NULL
 *       BOOL
 *       NUMBER
 *       STRING
 *       OBJECT
 *         SingleSelection
 *       ARRAY
 *     Sequence
 *       ARRAY
 *       Stream
 *         StreamSelection
 *           Table
 *     Database
 *     Function
 *     Ordering - used only by ORDER_BY
 *     Pathspec -- an object, string, or array that specifies a path
 *   Error
 */
struct  _Term
{
  ProtobufCMessage base;
  protobuf_c_boolean has_type;
  Term__TermType type;
  /*
   * This is only used when type is DATUM.
   */
  Datum *datum;
  /*
   * Holds the positional arguments of the query.
   */
  size_t n_args;
  Term **args;
  /*
   * Holds the optional arguments of the query.
   */
  size_t n_optargs;
  Term__AssocPair **optargs;
};
#define TERM__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&term__descriptor) \
    , 0, TERM__TERM_TYPE__DATUM, NULL, 0,NULL, 0,NULL }


/* VersionDummy methods */
void   version_dummy__init
                     (VersionDummy         *message);
size_t version_dummy__get_packed_size
                     (const VersionDummy   *message);
size_t version_dummy__pack
                     (const VersionDummy   *message,
                      uint8_t             *out);
size_t version_dummy__pack_to_buffer
                     (const VersionDummy   *message,
                      ProtobufCBuffer     *buffer);
VersionDummy *
       version_dummy__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   version_dummy__free_unpacked
                     (VersionDummy *message,
                      ProtobufCAllocator *allocator);
/* Query__AssocPair methods */
void   query__assoc_pair__init
                     (Query__AssocPair         *message);
/* Query methods */
void   query__init
                     (Query         *message);
size_t query__get_packed_size
                     (const Query   *message);
size_t query__pack
                     (const Query   *message,
                      uint8_t             *out);
size_t query__pack_to_buffer
                     (const Query   *message,
                      ProtobufCBuffer     *buffer);
Query *
       query__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   query__free_unpacked
                     (Query *message,
                      ProtobufCAllocator *allocator);
/* Frame methods */
void   frame__init
                     (Frame         *message);
size_t frame__get_packed_size
                     (const Frame   *message);
size_t frame__pack
                     (const Frame   *message,
                      uint8_t             *out);
size_t frame__pack_to_buffer
                     (const Frame   *message,
                      ProtobufCBuffer     *buffer);
Frame *
       frame__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   frame__free_unpacked
                     (Frame *message,
                      ProtobufCAllocator *allocator);
/* Backtrace methods */
void   backtrace__init
                     (Backtrace         *message);
size_t backtrace__get_packed_size
                     (const Backtrace   *message);
size_t backtrace__pack
                     (const Backtrace   *message,
                      uint8_t             *out);
size_t backtrace__pack_to_buffer
                     (const Backtrace   *message,
                      ProtobufCBuffer     *buffer);
Backtrace *
       backtrace__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   backtrace__free_unpacked
                     (Backtrace *message,
                      ProtobufCAllocator *allocator);
/* Response methods */
void   response__init
                     (Response         *message);
size_t response__get_packed_size
                     (const Response   *message);
size_t response__pack
                     (const Response   *message,
                      uint8_t             *out);
size_t response__pack_to_buffer
                     (const Response   *message,
                      ProtobufCBuffer     *buffer);
Response *
       response__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   response__free_unpacked
                     (Response *message,
                      ProtobufCAllocator *allocator);
/* Datum__AssocPair methods */
void   datum__assoc_pair__init
                     (Datum__AssocPair         *message);
/* Datum methods */
void   datum__init
                     (Datum         *message);
size_t datum__get_packed_size
                     (const Datum   *message);
size_t datum__pack
                     (const Datum   *message,
                      uint8_t             *out);
size_t datum__pack_to_buffer
                     (const Datum   *message,
                      ProtobufCBuffer     *buffer);
Datum *
       datum__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   datum__free_unpacked
                     (Datum *message,
                      ProtobufCAllocator *allocator);
/* Term__AssocPair methods */
void   term__assoc_pair__init
                     (Term__AssocPair         *message);
/* Term methods */
void   term__init
                     (Term         *message);
size_t term__get_packed_size
                     (const Term   *message);
size_t term__pack
                     (const Term   *message,
                      uint8_t             *out);
size_t term__pack_to_buffer
                     (const Term   *message,
                      ProtobufCBuffer     *buffer);
Term *
       term__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   term__free_unpacked
                     (Term *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*VersionDummy_Closure)
                 (const VersionDummy *message,
                  void *closure_data);
typedef void (*Query__AssocPair_Closure)
                 (const Query__AssocPair *message,
                  void *closure_data);
typedef void (*Query_Closure)
                 (const Query *message,
                  void *closure_data);
typedef void (*Frame_Closure)
                 (const Frame *message,
                  void *closure_data);
typedef void (*Backtrace_Closure)
                 (const Backtrace *message,
                  void *closure_data);
typedef void (*Response_Closure)
                 (const Response *message,
                  void *closure_data);
typedef void (*Datum__AssocPair_Closure)
                 (const Datum__AssocPair *message,
                  void *closure_data);
typedef void (*Datum_Closure)
                 (const Datum *message,
                  void *closure_data);
typedef void (*Term__AssocPair_Closure)
                 (const Term__AssocPair *message,
                  void *closure_data);
typedef void (*Term_Closure)
                 (const Term *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCMessageDescriptor version_dummy__descriptor;
extern const ProtobufCEnumDescriptor    version_dummy__version__descriptor;
extern const ProtobufCEnumDescriptor    version_dummy__protocol__descriptor;
extern const ProtobufCMessageDescriptor query__descriptor;
extern const ProtobufCMessageDescriptor query__assoc_pair__descriptor;
extern const ProtobufCEnumDescriptor    query__query_type__descriptor;
extern const ProtobufCMessageDescriptor frame__descriptor;
extern const ProtobufCEnumDescriptor    frame__frame_type__descriptor;
extern const ProtobufCMessageDescriptor backtrace__descriptor;
extern const ProtobufCMessageDescriptor response__descriptor;
extern const ProtobufCEnumDescriptor    response__response_type__descriptor;
extern const ProtobufCEnumDescriptor    response__error_type__descriptor;
extern const ProtobufCEnumDescriptor    response__response_note__descriptor;
extern const ProtobufCMessageDescriptor datum__descriptor;
extern const ProtobufCMessageDescriptor datum__assoc_pair__descriptor;
extern const ProtobufCEnumDescriptor    datum__datum_type__descriptor;
extern const ProtobufCMessageDescriptor term__descriptor;
extern const ProtobufCMessageDescriptor term__assoc_pair__descriptor;
extern const ProtobufCEnumDescriptor    term__term_type__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_ql2_2eproto__INCLUDED */
